// Copyright (c) Microsoft. All rights reserved.

// This sample shows how to create and use a simple AI agent with Azure Foundry Agents as the backend.

using System.Text;
using Azure.AI.Agents;
using Azure.Identity;
using Microsoft.Agents.AI;
using Microsoft.Extensions.AI;
using OpenAI.Assistants;
using OpenAI.Responses;

string endpoint = Environment.GetEnvironmentVariable("AZURE_FOUNDRY_PROJECT_ENDPOINT") ?? throw new InvalidOperationException("AZURE_FOUNDRY_PROJECT_ENDPOINT is not set.");
string deploymentName = Environment.GetEnvironmentVariable("AZURE_FOUNDRY_PROJECT_DEPLOYMENT_NAME") ?? "gpt-4o-mini";

const string AgentInstructions = "You are a helpful agent that can help fetch data from files you know about.";
const string AgentNameMEAI = "CoderAgent-MEAI";
const string AgentNameNative = "CoderAgent-NATIVE";

// Get a client to create/retrieve/delete server side agents with Azure Foundry Agents.
AgentClient agentClient = new(new Uri(endpoint), new AzureCliCredential());

// Option 1 - Using HostedCodeInterpreterTool MEAI abstraction
ChatClientAgentOptions agentOptions = new()
{
    Name = AgentNameMEAI,
    Instructions = AgentInstructions,
    ChatOptions = new() { Tools = [new HostedCodeInterpreterTool() { Inputs = [] }] }
};

AIAgent agentOption1 = await agentClient.CreateAIAgentAsync(model: deploymentName, agentOptions);

// Option 2 - Using PromptAgentDefinition SDK native type
AgentVersionCreationOptions options = new(new PromptAgentDefinition(model: deploymentName)
{
    Instructions = AgentInstructions,
    Tools = {
                ResponseTool.CreateCodeInterpreterTool(
                    new CodeInterpreterToolContainer(
                        CodeInterpreterToolContainerConfiguration.CreateAutomaticContainerConfiguration(fileIds: [])
                    )
                ),
            }
});

// You create the server side agent version.
AIAgent agentOption2 = await agentClient.CreateAIAgentAsync(name: AgentNameNative, options);

// Either invoke option1 or option2 agent, should have same result
var response = await agentOption1.RunAsync("I need to solve the equation sin(x) + x^2 = 42");
// var response = await agentOption2.RunAsync("I need to solve the equation sin(x) + x^2 = 42");

// Get the CodeInterpreterToolCallContent
var toolCallContent = response.Messages.SelectMany(m => m.Contents).OfType<CodeInterpreterToolCallContent>().SingleOrDefault();
if (toolCallContent?.Inputs is not null)
{
    var codeInput = toolCallContent.Inputs.OfType<DataContent>().FirstOrDefault();
    if (codeInput?.HasTopLevelMediaType("text") ?? false)
    {
        Console.WriteLine($"Code Input: {Encoding.UTF8.GetString(codeInput.Data.ToArray()) ?? "Not available"}");
    }
}

// Get the CodeInterpreterToolResultContent
var toolResultContent = response.Messages.SelectMany(m => m.Contents).OfType<CodeInterpreterToolResultContent>().FirstOrDefault();
if (toolResultContent?.Outputs is not null && toolResultContent.Outputs.OfType<TextContent>().FirstOrDefault() is { } resultOutput)
{
    Console.WriteLine($"Code Tool Result: {resultOutput.Text}");
}

// Getting any annotations generated by the tool
foreach (AIAnnotation annotation in response.Messages.SelectMany(m => m.Contents).SelectMany(C => C.Annotations ?? []))
{
    if (annotation.RawRepresentation is TextAnnotationUpdate citationAnnotation)
    {
        Console.WriteLine($$"""
            File Id: {{citationAnnotation.OutputFileId}}
            Text to Replace: {{citationAnnotation.TextToReplace}}
            Filename: {{Path.GetFileName(citationAnnotation.TextToReplace)}}
            """);
    }
}

// Cleanup by agent name removes the agent version created.
await agentClient.DeleteAgentAsync(agentOption1.Name);
await agentClient.DeleteAgentAsync(agentOption2.Name);
